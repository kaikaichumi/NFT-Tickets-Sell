{"ast":null,"code":"/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nvar SDPUtils = require('sdp');\nvar logging = require('../utils').log;\nvar edgeShim = {\n  shimPeerConnection: function () {\n    if (window.RTCIceGatherer) {\n      // ORTC defines an RTCIceCandidate object but no constructor.\n      // Not implemented in Edge.\n      if (!window.RTCIceCandidate) {\n        window.RTCIceCandidate = function (args) {\n          return args;\n        };\n      }\n      // ORTC does not have a session description object but\n      // other browsers (i.e. Chrome) that will support both PC and ORTC\n      // in the future might have this defined already.\n      if (!window.RTCSessionDescription) {\n        window.RTCSessionDescription = function (args) {\n          return args;\n        };\n      }\n    }\n    window.RTCPeerConnection = function (config) {\n      var self = this;\n      var _eventTarget = document.createDocumentFragment();\n      ['addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(function (method) {\n        self[method] = _eventTarget[method].bind(_eventTarget);\n      });\n      this.onicecandidate = null;\n      this.onaddstream = null;\n      this.ontrack = null;\n      this.onremovestream = null;\n      this.onsignalingstatechange = null;\n      this.oniceconnectionstatechange = null;\n      this.onnegotiationneeded = null;\n      this.ondatachannel = null;\n      this.localStreams = [];\n      this.remoteStreams = [];\n      this.getLocalStreams = function () {\n        return self.localStreams;\n      };\n      this.getRemoteStreams = function () {\n        return self.remoteStreams;\n      };\n      this.localDescription = new RTCSessionDescription({\n        type: '',\n        sdp: ''\n      });\n      this.remoteDescription = new RTCSessionDescription({\n        type: '',\n        sdp: ''\n      });\n      this.signalingState = 'stable';\n      this.iceConnectionState = 'new';\n      this.iceGatheringState = 'new';\n      this.iceOptions = {\n        gatherPolicy: 'all',\n        iceServers: []\n      };\n      if (config && config.iceTransportPolicy) {\n        switch (config.iceTransportPolicy) {\n          case 'all':\n          case 'relay':\n            this.iceOptions.gatherPolicy = config.iceTransportPolicy;\n            break;\n          case 'none':\n            // FIXME: remove once implementation and spec have added this.\n            throw new TypeError('iceTransportPolicy \"none\" not supported');\n          default:\n            // don't set iceTransportPolicy.\n            break;\n        }\n      }\n      this.usingBundle = config && config.bundlePolicy === 'max-bundle';\n      if (config && config.iceServers) {\n        // Edge does not like\n        // 1) stun:\n        // 2) turn: that does not have all of turn:host:port?transport=udp\n        var iceServers = JSON.parse(JSON.stringify(config.iceServers));\n        this.iceOptions.iceServers = iceServers.filter(function (server) {\n          if (server && server.urls) {\n            var urls = server.urls;\n            if (typeof urls === 'string') {\n              urls = [urls];\n            }\n            urls = urls.filter(function (url) {\n              return url.indexOf('turn:') === 0 && url.indexOf('transport=udp') !== -1;\n            })[0];\n            return !!urls;\n          }\n          return false;\n        });\n      }\n\n      // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n      // everything that is needed to describe a SDP m-line.\n      this.transceivers = [];\n\n      // since the iceGatherer is currently created in createOffer but we\n      // must not emit candidates until after setLocalDescription we buffer\n      // them in this array.\n      this._localIceCandidatesBuffer = [];\n    };\n    window.RTCPeerConnection.prototype._emitBufferedCandidates = function () {\n      var self = this;\n      var sections = SDPUtils.splitSections(self.localDescription.sdp);\n      // FIXME: need to apply ice candidates in a way which is async but\n      // in-order\n      this._localIceCandidatesBuffer.forEach(function (event) {\n        var end = !event.candidate || Object.keys(event.candidate).length === 0;\n        if (end) {\n          for (var j = 1; j < sections.length; j++) {\n            if (sections[j].indexOf('\\r\\na=end-of-candidates\\r\\n') === -1) {\n              sections[j] += 'a=end-of-candidates\\r\\n';\n            }\n          }\n        } else if (event.candidate.candidate.indexOf('typ endOfCandidates') === -1) {\n          sections[event.candidate.sdpMLineIndex + 1] += 'a=' + event.candidate.candidate + '\\r\\n';\n        }\n        self.localDescription.sdp = sections.join('');\n        self.dispatchEvent(event);\n        if (self.onicecandidate !== null) {\n          self.onicecandidate(event);\n        }\n        if (!event.candidate && self.iceGatheringState !== 'complete') {\n          var complete = self.transceivers.every(function (transceiver) {\n            return transceiver.iceGatherer && transceiver.iceGatherer.state === 'completed';\n          });\n          if (complete) {\n            self.iceGatheringState = 'complete';\n          }\n        }\n      });\n      this._localIceCandidatesBuffer = [];\n    };\n    window.RTCPeerConnection.prototype.addStream = function (stream) {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      this.localStreams.push(stream.clone());\n      this._maybeFireNegotiationNeeded();\n    };\n    window.RTCPeerConnection.prototype.removeStream = function (stream) {\n      var idx = this.localStreams.indexOf(stream);\n      if (idx > -1) {\n        this.localStreams.splice(idx, 1);\n        this._maybeFireNegotiationNeeded();\n      }\n    };\n    window.RTCPeerConnection.prototype.getSenders = function () {\n      return this.transceivers.filter(function (transceiver) {\n        return !!transceiver.rtpSender;\n      }).map(function (transceiver) {\n        return transceiver.rtpSender;\n      });\n    };\n    window.RTCPeerConnection.prototype.getReceivers = function () {\n      return this.transceivers.filter(function (transceiver) {\n        return !!transceiver.rtpReceiver;\n      }).map(function (transceiver) {\n        return transceiver.rtpReceiver;\n      });\n    };\n\n    // Determines the intersection of local and remote capabilities.\n    window.RTCPeerConnection.prototype._getCommonCapabilities = function (localCapabilities, remoteCapabilities) {\n      var commonCapabilities = {\n        codecs: [],\n        headerExtensions: [],\n        fecMechanisms: []\n      };\n      localCapabilities.codecs.forEach(function (lCodec) {\n        for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n          var rCodec = remoteCapabilities.codecs[i];\n          if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() && lCodec.clockRate === rCodec.clockRate && lCodec.numChannels === rCodec.numChannels) {\n            // push rCodec so we reply with offerer payload type\n            commonCapabilities.codecs.push(rCodec);\n\n            // FIXME: also need to determine intersection between\n            // .rtcpFeedback and .parameters\n            break;\n          }\n        }\n      });\n      localCapabilities.headerExtensions.forEach(function (lHeaderExtension) {\n        for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {\n          var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n          if (lHeaderExtension.uri === rHeaderExtension.uri) {\n            commonCapabilities.headerExtensions.push(rHeaderExtension);\n            break;\n          }\n        }\n      });\n\n      // FIXME: fecMechanisms\n      return commonCapabilities;\n    };\n\n    // Create ICE gatherer, ICE transport and DTLS transport.\n    window.RTCPeerConnection.prototype._createIceAndDtlsTransports = function (mid, sdpMLineIndex) {\n      var self = this;\n      var iceGatherer = new RTCIceGatherer(self.iceOptions);\n      var iceTransport = new RTCIceTransport(iceGatherer);\n      iceGatherer.onlocalcandidate = function (evt) {\n        var event = new Event('icecandidate');\n        event.candidate = {\n          sdpMid: mid,\n          sdpMLineIndex: sdpMLineIndex\n        };\n        var cand = evt.candidate;\n        var end = !cand || Object.keys(cand).length === 0;\n        // Edge emits an empty object for RTCIceCandidateCompleteâ€¥\n        if (end) {\n          // polyfill since RTCIceGatherer.state is not implemented in\n          // Edge 10547 yet.\n          if (iceGatherer.state === undefined) {\n            iceGatherer.state = 'completed';\n          }\n\n          // Emit a candidate with type endOfCandidates to make the samples\n          // work. Edge requires addIceCandidate with this empty candidate\n          // to start checking. The real solution is to signal\n          // end-of-candidates to the other side when getting the null\n          // candidate but some apps (like the samples) don't do that.\n          event.candidate.candidate = 'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates';\n        } else {\n          // RTCIceCandidate doesn't have a component, needs to be added\n          cand.component = iceTransport.component === 'RTCP' ? 2 : 1;\n          event.candidate.candidate = SDPUtils.writeCandidate(cand);\n        }\n\n        // update local description.\n        var sections = SDPUtils.splitSections(self.localDescription.sdp);\n        if (event.candidate.candidate.indexOf('typ endOfCandidates') === -1) {\n          sections[event.candidate.sdpMLineIndex + 1] += 'a=' + event.candidate.candidate + '\\r\\n';\n        } else {\n          sections[event.candidate.sdpMLineIndex + 1] += 'a=end-of-candidates\\r\\n';\n        }\n        self.localDescription.sdp = sections.join('');\n        var complete = self.transceivers.every(function (transceiver) {\n          return transceiver.iceGatherer && transceiver.iceGatherer.state === 'completed';\n        });\n\n        // Emit candidate if localDescription is set.\n        // Also emits null candidate when all gatherers are complete.\n        switch (self.iceGatheringState) {\n          case 'new':\n            self._localIceCandidatesBuffer.push(event);\n            if (end && complete) {\n              self._localIceCandidatesBuffer.push(new Event('icecandidate'));\n            }\n            break;\n          case 'gathering':\n            self._emitBufferedCandidates();\n            self.dispatchEvent(event);\n            if (self.onicecandidate !== null) {\n              self.onicecandidate(event);\n            }\n            if (complete) {\n              self.dispatchEvent(new Event('icecandidate'));\n              if (self.onicecandidate !== null) {\n                self.onicecandidate(new Event('icecandidate'));\n              }\n              self.iceGatheringState = 'complete';\n            }\n            break;\n          case 'complete':\n            // should not happen... currently!\n            break;\n          default:\n            // no-op.\n            break;\n        }\n      };\n      iceTransport.onicestatechange = function () {\n        self._updateConnectionState();\n      };\n      var dtlsTransport = new RTCDtlsTransport(iceTransport);\n      dtlsTransport.ondtlsstatechange = function () {\n        self._updateConnectionState();\n      };\n      dtlsTransport.onerror = function () {\n        // onerror does not set state to failed by itself.\n        dtlsTransport.state = 'failed';\n        self._updateConnectionState();\n      };\n      return {\n        iceGatherer: iceGatherer,\n        iceTransport: iceTransport,\n        dtlsTransport: dtlsTransport\n      };\n    };\n\n    // Start the RTP Sender and Receiver for a transceiver.\n    window.RTCPeerConnection.prototype._transceive = function (transceiver, send, recv) {\n      var params = this._getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);\n      if (send && transceiver.rtpSender) {\n        params.encodings = transceiver.sendEncodingParameters;\n        params.rtcp = {\n          cname: SDPUtils.localCName\n        };\n        if (transceiver.recvEncodingParameters.length) {\n          params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n        }\n        transceiver.rtpSender.send(params);\n      }\n      if (recv && transceiver.rtpReceiver) {\n        params.encodings = transceiver.recvEncodingParameters;\n        params.rtcp = {\n          cname: transceiver.cname\n        };\n        if (transceiver.sendEncodingParameters.length) {\n          params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n        }\n        transceiver.rtpReceiver.receive(params);\n      }\n    };\n    window.RTCPeerConnection.prototype.setLocalDescription = function (description) {\n      var self = this;\n      var sections;\n      var sessionpart;\n      if (description.type === 'offer') {\n        // FIXME: What was the purpose of this empty if statement?\n        // if (!this._pendingOffer) {\n        // } else {\n        if (this._pendingOffer) {\n          // VERY limited support for SDP munging. Limited to:\n          // * changing the order of codecs\n          sections = SDPUtils.splitSections(description.sdp);\n          sessionpart = sections.shift();\n          sections.forEach(function (mediaSection, sdpMLineIndex) {\n            var caps = SDPUtils.parseRtpParameters(mediaSection);\n            self._pendingOffer[sdpMLineIndex].localCapabilities = caps;\n          });\n          this.transceivers = this._pendingOffer;\n          delete this._pendingOffer;\n        }\n      } else if (description.type === 'answer') {\n        sections = SDPUtils.splitSections(self.remoteDescription.sdp);\n        sessionpart = sections.shift();\n        var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;\n        sections.forEach(function (mediaSection, sdpMLineIndex) {\n          var transceiver = self.transceivers[sdpMLineIndex];\n          var iceGatherer = transceiver.iceGatherer;\n          var iceTransport = transceiver.iceTransport;\n          var dtlsTransport = transceiver.dtlsTransport;\n          var localCapabilities = transceiver.localCapabilities;\n          var remoteCapabilities = transceiver.remoteCapabilities;\n          var rejected = mediaSection.split('\\n', 1)[0].split(' ', 2)[1] === '0';\n          if (!rejected) {\n            var remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);\n            if (isIceLite) {\n              var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:').map(function (cand) {\n                return SDPUtils.parseCandidate(cand);\n              }).filter(function (cand) {\n                return cand.component === '1';\n              });\n              // ice-lite only includes host candidates in the SDP so we can\n              // use setRemoteCandidates (which implies an\n              // RTCIceCandidateComplete)\n              if (cands.length) {\n                iceTransport.setRemoteCandidates(cands);\n              }\n            }\n            var remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);\n            if (isIceLite) {\n              remoteDtlsParameters.role = 'server';\n            }\n            if (!self.usingBundle || sdpMLineIndex === 0) {\n              iceTransport.start(iceGatherer, remoteIceParameters, isIceLite ? 'controlling' : 'controlled');\n              dtlsTransport.start(remoteDtlsParameters);\n            }\n\n            // Calculate intersection of capabilities.\n            var params = self._getCommonCapabilities(localCapabilities, remoteCapabilities);\n\n            // Start the RTCRtpSender. The RTCRtpReceiver for this\n            // transceiver has already been started in setRemoteDescription.\n            self._transceive(transceiver, params.codecs.length > 0, false);\n          }\n        });\n      }\n      this.localDescription = {\n        type: description.type,\n        sdp: description.sdp\n      };\n      switch (description.type) {\n        case 'offer':\n          this._updateSignalingState('have-local-offer');\n          break;\n        case 'answer':\n          this._updateSignalingState('stable');\n          break;\n        default:\n          throw new TypeError('unsupported type \"' + description.type + '\"');\n      }\n\n      // If a success callback was provided, emit ICE candidates after it\n      // has been executed. Otherwise, emit callback after the Promise is\n      // resolved.\n      var hasCallback = arguments.length > 1 && typeof arguments[1] === 'function';\n      if (hasCallback) {\n        var cb = arguments[1];\n        window.setTimeout(function () {\n          cb();\n          if (self.iceGatheringState === 'new') {\n            self.iceGatheringState = 'gathering';\n          }\n          self._emitBufferedCandidates();\n        }, 0);\n      }\n      var p = Promise.resolve();\n      p.then(function () {\n        if (!hasCallback) {\n          if (self.iceGatheringState === 'new') {\n            self.iceGatheringState = 'gathering';\n          }\n          // Usually candidates will be emitted earlier.\n          window.setTimeout(self._emitBufferedCandidates.bind(self), 500);\n        }\n      });\n      return p;\n    };\n    window.RTCPeerConnection.prototype.setRemoteDescription = function (description) {\n      var self = this;\n      var stream = new MediaStream();\n      var receiverList = [];\n      var sections = SDPUtils.splitSections(description.sdp);\n      var sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;\n      this.usingBundle = SDPUtils.matchPrefix(sessionpart, 'a=group:BUNDLE ').length > 0;\n      sections.forEach(function (mediaSection, sdpMLineIndex) {\n        var lines = SDPUtils.splitLines(mediaSection);\n        var mline = lines[0].substr(2).split(' ');\n        var kind = mline[0];\n        var rejected = mline[1] === '0';\n        var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n        var transceiver;\n        var iceGatherer;\n        var iceTransport;\n        var dtlsTransport;\n        var rtpSender;\n        var rtpReceiver;\n        var sendEncodingParameters;\n        var recvEncodingParameters;\n        var localCapabilities;\n        var track;\n        // FIXME: ensure the mediaSection has rtcp-mux set.\n        var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n        var remoteIceParameters;\n        var remoteDtlsParameters;\n        if (!rejected) {\n          remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);\n          remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);\n          remoteDtlsParameters.role = 'client';\n        }\n        recvEncodingParameters = SDPUtils.parseRtpEncodingParameters(mediaSection);\n        var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:');\n        if (mid.length) {\n          mid = mid[0].substr(6);\n        } else {\n          mid = SDPUtils.generateIdentifier();\n        }\n        var cname;\n        // Gets the first SSRC. Note that with RTX there might be multiple\n        // SSRCs.\n        var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {\n          return SDPUtils.parseSsrcMedia(line);\n        }).filter(function (obj) {\n          return obj.attribute === 'cname';\n        })[0];\n        if (remoteSsrc) {\n          cname = remoteSsrc.value;\n        }\n        var isComplete = SDPUtils.matchPrefix(mediaSection, 'a=end-of-candidates').length > 0;\n        var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:').map(function (cand) {\n          return SDPUtils.parseCandidate(cand);\n        }).filter(function (cand) {\n          return cand.component === '1';\n        });\n        if (description.type === 'offer' && !rejected) {\n          var transports = self.usingBundle && sdpMLineIndex > 0 ? {\n            iceGatherer: self.transceivers[0].iceGatherer,\n            iceTransport: self.transceivers[0].iceTransport,\n            dtlsTransport: self.transceivers[0].dtlsTransport\n          } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);\n          if (isComplete) {\n            transports.iceTransport.setRemoteCandidates(cands);\n          }\n          localCapabilities = RTCRtpReceiver.getCapabilities(kind);\n          sendEncodingParameters = [{\n            ssrc: (2 * sdpMLineIndex + 2) * 1001\n          }];\n          rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);\n          track = rtpReceiver.track;\n          receiverList.push([track, rtpReceiver]);\n          // FIXME: not correct when there are multiple streams but that is\n          // not currently supported in this shim.\n          stream.addTrack(track);\n\n          // FIXME: look at direction.\n          if (self.localStreams.length > 0 && self.localStreams[0].getTracks().length >= sdpMLineIndex) {\n            // FIXME: actually more complicated, needs to match types etc\n            var localtrack = self.localStreams[0].getTracks()[sdpMLineIndex];\n            rtpSender = new RTCRtpSender(localtrack, transports.dtlsTransport);\n          }\n          self.transceivers[sdpMLineIndex] = {\n            iceGatherer: transports.iceGatherer,\n            iceTransport: transports.iceTransport,\n            dtlsTransport: transports.dtlsTransport,\n            localCapabilities: localCapabilities,\n            remoteCapabilities: remoteCapabilities,\n            rtpSender: rtpSender,\n            rtpReceiver: rtpReceiver,\n            kind: kind,\n            mid: mid,\n            cname: cname,\n            sendEncodingParameters: sendEncodingParameters,\n            recvEncodingParameters: recvEncodingParameters\n          };\n          // Start the RTCRtpReceiver now. The RTPSender is started in\n          // setLocalDescription.\n          self._transceive(self.transceivers[sdpMLineIndex], false, direction === 'sendrecv' || direction === 'sendonly');\n        } else if (description.type === 'answer' && !rejected) {\n          transceiver = self.transceivers[sdpMLineIndex];\n          iceGatherer = transceiver.iceGatherer;\n          iceTransport = transceiver.iceTransport;\n          dtlsTransport = transceiver.dtlsTransport;\n          rtpSender = transceiver.rtpSender;\n          rtpReceiver = transceiver.rtpReceiver;\n          sendEncodingParameters = transceiver.sendEncodingParameters;\n          localCapabilities = transceiver.localCapabilities;\n          self.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters;\n          self.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities;\n          self.transceivers[sdpMLineIndex].cname = cname;\n          if ((isIceLite || isComplete) && cands.length) {\n            iceTransport.setRemoteCandidates(cands);\n          }\n          if (!self.usingBundle || sdpMLineIndex === 0) {\n            iceTransport.start(iceGatherer, remoteIceParameters, 'controlling');\n            dtlsTransport.start(remoteDtlsParameters);\n          }\n          self._transceive(transceiver, direction === 'sendrecv' || direction === 'recvonly', direction === 'sendrecv' || direction === 'sendonly');\n          if (rtpReceiver && (direction === 'sendrecv' || direction === 'sendonly')) {\n            track = rtpReceiver.track;\n            receiverList.push([track, rtpReceiver]);\n            stream.addTrack(track);\n          } else {\n            // FIXME: actually the receiver should be created later.\n            delete transceiver.rtpReceiver;\n          }\n        }\n      });\n      this.remoteDescription = {\n        type: description.type,\n        sdp: description.sdp\n      };\n      switch (description.type) {\n        case 'offer':\n          this._updateSignalingState('have-remote-offer');\n          break;\n        case 'answer':\n          this._updateSignalingState('stable');\n          break;\n        default:\n          throw new TypeError('unsupported type \"' + description.type + '\"');\n      }\n      if (stream.getTracks().length) {\n        self.remoteStreams.push(stream);\n        window.setTimeout(function () {\n          var event = new Event('addstream');\n          event.stream = stream;\n          self.dispatchEvent(event);\n          if (self.onaddstream !== null) {\n            window.setTimeout(function () {\n              self.onaddstream(event);\n            }, 0);\n          }\n          receiverList.forEach(function (item) {\n            var track = item[0];\n            var receiver = item[1];\n            var trackEvent = new Event('track');\n            trackEvent.track = track;\n            trackEvent.receiver = receiver;\n            trackEvent.streams = [stream];\n            self.dispatchEvent(event);\n            if (self.ontrack !== null) {\n              window.setTimeout(function () {\n                self.ontrack(trackEvent);\n              }, 0);\n            }\n          });\n        }, 0);\n      }\n      if (arguments.length > 1 && typeof arguments[1] === 'function') {\n        window.setTimeout(arguments[1], 0);\n      }\n      return Promise.resolve();\n    };\n    window.RTCPeerConnection.prototype.close = function () {\n      this.transceivers.forEach(function (transceiver) {\n        /* not yet\n        if (transceiver.iceGatherer) {\n          transceiver.iceGatherer.close();\n        }\n        */\n        if (transceiver.iceTransport) {\n          transceiver.iceTransport.stop();\n        }\n        if (transceiver.dtlsTransport) {\n          transceiver.dtlsTransport.stop();\n        }\n        if (transceiver.rtpSender) {\n          transceiver.rtpSender.stop();\n        }\n        if (transceiver.rtpReceiver) {\n          transceiver.rtpReceiver.stop();\n        }\n      });\n      // FIXME: clean up tracks, local streams, remote streams, etc\n      this._updateSignalingState('closed');\n    };\n\n    // Update the signaling state.\n    window.RTCPeerConnection.prototype._updateSignalingState = function (newState) {\n      this.signalingState = newState;\n      var event = new Event('signalingstatechange');\n      this.dispatchEvent(event);\n      if (this.onsignalingstatechange !== null) {\n        this.onsignalingstatechange(event);\n      }\n    };\n\n    // Determine whether to fire the negotiationneeded event.\n    window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function () {\n      // Fire away (for now).\n      var event = new Event('negotiationneeded');\n      this.dispatchEvent(event);\n      if (this.onnegotiationneeded !== null) {\n        this.onnegotiationneeded(event);\n      }\n    };\n\n    // Update the connection state.\n    window.RTCPeerConnection.prototype._updateConnectionState = function () {\n      var self = this;\n      var newState;\n      var states = {\n        'new': 0,\n        closed: 0,\n        connecting: 0,\n        checking: 0,\n        connected: 0,\n        completed: 0,\n        failed: 0\n      };\n      this.transceivers.forEach(function (transceiver) {\n        states[transceiver.iceTransport.state]++;\n        states[transceiver.dtlsTransport.state]++;\n      });\n      // ICETransport.completed and connected are the same for this purpose.\n      states.connected += states.completed;\n      newState = 'new';\n      if (states.failed > 0) {\n        newState = 'failed';\n      } else if (states.connecting > 0 || states.checking > 0) {\n        newState = 'connecting';\n      } else if (states.disconnected > 0) {\n        newState = 'disconnected';\n      } else if (states.new > 0) {\n        newState = 'new';\n      } else if (states.connected > 0 || states.completed > 0) {\n        newState = 'connected';\n      }\n      if (newState !== self.iceConnectionState) {\n        self.iceConnectionState = newState;\n        var event = new Event('iceconnectionstatechange');\n        this.dispatchEvent(event);\n        if (this.oniceconnectionstatechange !== null) {\n          this.oniceconnectionstatechange(event);\n        }\n      }\n    };\n    window.RTCPeerConnection.prototype.createOffer = function () {\n      var self = this;\n      if (this._pendingOffer) {\n        throw new Error('createOffer called while there is a pending offer.');\n      }\n      var offerOptions;\n      if (arguments.length === 1 && typeof arguments[0] !== 'function') {\n        offerOptions = arguments[0];\n      } else if (arguments.length === 3) {\n        offerOptions = arguments[2];\n      }\n      var tracks = [];\n      var numAudioTracks = 0;\n      var numVideoTracks = 0;\n      // Default to sendrecv.\n      if (this.localStreams.length) {\n        numAudioTracks = this.localStreams[0].getAudioTracks().length;\n        numVideoTracks = this.localStreams[0].getVideoTracks().length;\n      }\n      // Determine number of audio and video tracks we need to send/recv.\n      if (offerOptions) {\n        // Reject Chrome legacy constraints.\n        if (offerOptions.mandatory || offerOptions.optional) {\n          throw new TypeError('Legacy mandatory/optional constraints not supported.');\n        }\n        if (offerOptions.offerToReceiveAudio !== undefined) {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n        if (offerOptions.offerToReceiveVideo !== undefined) {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n      if (this.localStreams.length) {\n        // Push local streams.\n        this.localStreams[0].getTracks().forEach(function (track) {\n          tracks.push({\n            kind: track.kind,\n            track: track,\n            wantReceive: track.kind === 'audio' ? numAudioTracks > 0 : numVideoTracks > 0\n          });\n          if (track.kind === 'audio') {\n            numAudioTracks--;\n          } else if (track.kind === 'video') {\n            numVideoTracks--;\n          }\n        });\n      }\n      // Create M-lines for recvonly streams.\n      while (numAudioTracks > 0 || numVideoTracks > 0) {\n        if (numAudioTracks > 0) {\n          tracks.push({\n            kind: 'audio',\n            wantReceive: true\n          });\n          numAudioTracks--;\n        }\n        if (numVideoTracks > 0) {\n          tracks.push({\n            kind: 'video',\n            wantReceive: true\n          });\n          numVideoTracks--;\n        }\n      }\n      var sdp = SDPUtils.writeSessionBoilerplate();\n      var transceivers = [];\n      tracks.forEach(function (mline, sdpMLineIndex) {\n        // For each track, create an ice gatherer, ice transport,\n        // dtls transport, potentially rtpsender and rtpreceiver.\n        var track = mline.track;\n        var kind = mline.kind;\n        var mid = SDPUtils.generateIdentifier();\n        var transports = self.usingBundle && sdpMLineIndex > 0 ? {\n          iceGatherer: transceivers[0].iceGatherer,\n          iceTransport: transceivers[0].iceTransport,\n          dtlsTransport: transceivers[0].dtlsTransport\n        } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);\n        var localCapabilities = RTCRtpSender.getCapabilities(kind);\n        var rtpSender;\n        var rtpReceiver;\n\n        // generate an ssrc now, to be used later in rtpSender.send\n        var sendEncodingParameters = [{\n          ssrc: (2 * sdpMLineIndex + 1) * 1001\n        }];\n        if (track) {\n          rtpSender = new RTCRtpSender(track, transports.dtlsTransport);\n        }\n        if (mline.wantReceive) {\n          rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);\n        }\n        transceivers[sdpMLineIndex] = {\n          iceGatherer: transports.iceGatherer,\n          iceTransport: transports.iceTransport,\n          dtlsTransport: transports.dtlsTransport,\n          localCapabilities: localCapabilities,\n          remoteCapabilities: null,\n          rtpSender: rtpSender,\n          rtpReceiver: rtpReceiver,\n          kind: kind,\n          mid: mid,\n          sendEncodingParameters: sendEncodingParameters,\n          recvEncodingParameters: null\n        };\n      });\n      if (this.usingBundle) {\n        sdp += 'a=group:BUNDLE ' + transceivers.map(function (t) {\n          return t.mid;\n        }).join(' ') + '\\r\\n';\n      }\n      tracks.forEach(function (mline, sdpMLineIndex) {\n        var transceiver = transceivers[sdpMLineIndex];\n        sdp += SDPUtils.writeMediaSection(transceiver, transceiver.localCapabilities, 'offer', self.localStreams[0]);\n      });\n      this._pendingOffer = transceivers;\n      var desc = new RTCSessionDescription({\n        type: 'offer',\n        sdp: sdp\n      });\n      if (arguments.length && typeof arguments[0] === 'function') {\n        window.setTimeout(arguments[0], 0, desc);\n      }\n      return Promise.resolve(desc);\n    };\n    window.RTCPeerConnection.prototype.createAnswer = function () {\n      var self = this;\n      var sdp = SDPUtils.writeSessionBoilerplate();\n      if (this.usingBundle) {\n        sdp += 'a=group:BUNDLE ' + this.transceivers.map(function (t) {\n          return t.mid;\n        }).join(' ') + '\\r\\n';\n      }\n      this.transceivers.forEach(function (transceiver) {\n        // Calculate intersection of capabilities.\n        var commonCapabilities = self._getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);\n        sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities, 'answer', self.localStreams[0]);\n      });\n      var desc = new RTCSessionDescription({\n        type: 'answer',\n        sdp: sdp\n      });\n      if (arguments.length && typeof arguments[0] === 'function') {\n        window.setTimeout(arguments[0], 0, desc);\n      }\n      return Promise.resolve(desc);\n    };\n    window.RTCPeerConnection.prototype.addIceCandidate = function (candidate) {\n      if (candidate === null) {\n        this.transceivers.forEach(function (transceiver) {\n          transceiver.iceTransport.addRemoteCandidate({});\n        });\n      } else {\n        var mLineIndex = candidate.sdpMLineIndex;\n        if (candidate.sdpMid) {\n          for (var i = 0; i < this.transceivers.length; i++) {\n            if (this.transceivers[i].mid === candidate.sdpMid) {\n              mLineIndex = i;\n              break;\n            }\n          }\n        }\n        var transceiver = this.transceivers[mLineIndex];\n        if (transceiver) {\n          var cand = Object.keys(candidate.candidate).length > 0 ? SDPUtils.parseCandidate(candidate.candidate) : {};\n          // Ignore Chrome's invalid candidates since Edge does not like them.\n          if (cand.protocol === 'tcp' && cand.port === 0) {\n            return;\n          }\n          // Ignore RTCP candidates, we assume RTCP-MUX.\n          if (cand.component !== '1') {\n            return;\n          }\n          // A dirty hack to make samples work.\n          if (cand.type === 'endOfCandidates') {\n            cand = {};\n          }\n          transceiver.iceTransport.addRemoteCandidate(cand);\n\n          // update the remoteDescription.\n          var sections = SDPUtils.splitSections(this.remoteDescription.sdp);\n          sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim() : 'a=end-of-candidates') + '\\r\\n';\n          this.remoteDescription.sdp = sections.join('');\n        }\n      }\n      if (arguments.length > 1 && typeof arguments[1] === 'function') {\n        window.setTimeout(arguments[1], 0);\n      }\n      return Promise.resolve();\n    };\n    window.RTCPeerConnection.prototype.getStats = function () {\n      var promises = [];\n      this.transceivers.forEach(function (transceiver) {\n        ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(function (method) {\n          if (transceiver[method]) {\n            promises.push(transceiver[method].getStats());\n          }\n        });\n      });\n      var cb = arguments.length > 1 && typeof arguments[1] === 'function' && arguments[1];\n      return new Promise(function (resolve) {\n        // shim getStats with maplike support\n        var results = new Map();\n        Promise.all(promises).then(function (res) {\n          res.forEach(function (result) {\n            Object.keys(result).forEach(function (id) {\n              results.set(id, result[id]);\n              results[id] = result[id];\n            });\n          });\n          if (cb) {\n            window.setTimeout(cb, 0, results);\n          }\n          resolve(results);\n        });\n      });\n    };\n  },\n  // Attach a media stream to an element.\n  attachMediaStream: function (element, stream) {\n    logging('DEPRECATED, attachMediaStream will soon be removed.');\n    element.srcObject = stream;\n  },\n  reattachMediaStream: function (to, from) {\n    logging('DEPRECATED, reattachMediaStream will soon be removed.');\n    to.srcObject = from.srcObject;\n  }\n};\n\n// Expose public methods.\nmodule.exports = {\n  shimPeerConnection: edgeShim.shimPeerConnection,\n  shimGetUserMedia: require('./getusermedia'),\n  attachMediaStream: edgeShim.attachMediaStream,\n  reattachMediaStream: edgeShim.reattachMediaStream\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}